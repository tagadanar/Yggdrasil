// packages/shared-utilities/src/patterns/cqrs.ts
import { v4 as uuidv4 } from 'uuid';
import { logger } from '../logging/logger';
import { EventBus } from '../events/event-bus';

/**
 * Base interface for all commands in the CQRS pattern.
 * Commands represent write operations that change system state.
 */
export interface Command<T = any> {
  /** Unique identifier for the command */
  id: string;
  /** Command type identifier */
  type: string;
  /** Command payload data */
  data: T;
  /** Additional metadata */
  metadata?: Record<string, any>;
  /** User or system that issued the command */
  issuedBy?: string;
  /** When the command was issued */
  issuedAt?: Date;
}

/**
 * Base interface for all queries in the CQRS pattern.
 * Queries represent read operations that don't change system state.
 */
export interface Query<T = any> {
  /** Query type identifier */
  type: string;
  /** Query filters and parameters */
  filters?: Record<string, any>;
  /** Fields to include in the result */
  projection?: string[];
  /** Sort criteria */
  sort?: Record<string, 1 | -1>;
  /** Maximum number of results */
  limit?: number;
  /** Number of results to skip */
  offset?: number;
  /** Additional query options */
  options?: T;
  /** User or system making the query */
  requestedBy?: string;
}

/**
 * Result wrapper for command execution.
 */
export interface CommandResult<T = any> {
  /** Whether the command succeeded */
  success: boolean;
  /** Result data from command execution */
  data?: T;
  /** Error information if command failed */
  error?: Error;
  /** Events generated by the command */
  events?: Array<{ type: string; data: any }>;
  /** Execution metadata */
  metadata?: Record<string, any>;
}

/**
 * Result wrapper for query execution.
 */
export interface QueryResult<T = any> {
  /** Query result data */
  data: T;
  /** Total count (for paginated queries) */
  total?: number;
  /** Query execution metadata */
  metadata?: Record<string, any>;
}

/**
 * Interface for command handlers.
 * Command handlers contain the business logic for processing commands.
 */
export interface CommandHandler<TCommand = any, TResult = any> {
  /** Handle a command and return a result */
  handle(command: Command<TCommand>): Promise<CommandResult<TResult>>;
  /** Validate command before execution (optional) */
  validate?(command: Command<TCommand>): Promise<void>;
  /** Get handler metadata (optional) */
  getMetadata?(): { name: string; description: string; version: string };
}

/**
 * Interface for query handlers.
 * Query handlers contain the logic for retrieving data.
 */
export interface QueryHandler<TQuery = any, TResult = any> {
  /** Handle a query and return a result */
  handle(query: Query<TQuery>): Promise<QueryResult<TResult>>;
  /** Validate query before execution (optional) */
  validate?(query: Query<TQuery>): Promise<void>;
  /** Get handler metadata (optional) */
  getMetadata?(): { name: string; description: string; version: string };
}

/**
 * Command bus for managing command execution in CQRS architecture.
 *
 * The command bus:
 * - Routes commands to appropriate handlers
 * - Provides validation and error handling
 * - Supports middleware for cross-cutting concerns
 * - Publishes events for command lifecycle
 * - Provides audit logging
 *
 * @example
 * ```typescript
 * const commandBus = new CommandBus(eventBus);
 *
 * // Register a handler
 * commandBus.register('user.create', new CreateUserHandler());
 *
 * // Execute a command
 * const result = await commandBus.execute({
 *   id: uuidv4(),
 *   type: 'user.create',
 *   data: { email: 'user@example.com', name: 'John Doe' }
 * });
 * ```
 */
export class CommandBus {
  private handlers = new Map<string, CommandHandler>();
  private middleware: Array<
    (command: Command, next: () => Promise<CommandResult>) => Promise<CommandResult>
  > = [];

  constructor(private eventBus?: EventBus) {}

  /**
   * Register a command handler for a specific command type.
   */
  register(commandType: string, handler: CommandHandler): void {
    if (this.handlers.has(commandType)) {
      throw new Error(`Handler already registered for command type: ${commandType}`);
    }

    this.handlers.set(commandType, handler);

    logger.debug(`Command handler registered: ${commandType}`, {
      handlerName: handler.getMetadata?.().name || 'Unknown',
    });
  }

  /**
   * Unregister a command handler.
   */
  unregister(commandType: string): boolean {
    const removed = this.handlers.delete(commandType);
    if (removed) {
      logger.debug(`Command handler unregistered: ${commandType}`);
    }
    return removed;
  }

  /**
   * Add middleware to the command processing pipeline.
   */
  use(
    middleware: (command: Command, next: () => Promise<CommandResult>) => Promise<CommandResult>,
  ): void {
    this.middleware.push(middleware);
  }

  /**
   * Execute a command through the registered handler.
   */
  async execute<TCommand, TResult>(command: Command<TCommand>): Promise<CommandResult<TResult>> {
    const startTime = Date.now();

    // Ensure command has required fields
    if (!command.id) command.id = uuidv4();
    if (!command.issuedAt) command.issuedAt = new Date();

    logger.info(`Executing command: ${command.type}`, {
      commandId: command.id,
      type: command.type,
      issuedBy: command.issuedBy,
    });

    try {
      // Publish command started event
      if (this.eventBus) {
        await this.eventBus.publish({
          type: 'command.started',
          data: {
            commandId: command.id,
            commandType: command.type,
            issuedBy: command.issuedBy,
          },
        });
      }

      // Execute through middleware chain
      const result = await this.executeWithMiddleware(command, 0);

      const executionTime = Date.now() - startTime;

      logger.info(`Command executed successfully: ${command.type}`, {
        commandId: command.id,
        success: result.success,
        executionTime,
      });

      // Publish command completed event
      if (this.eventBus) {
        await this.eventBus.publish({
          type: 'command.completed',
          data: {
            commandId: command.id,
            commandType: command.type,
            success: result.success,
            executionTime,
            eventsGenerated: result.events?.length || 0,
          },
        });

        // Publish any events generated by the command
        if (result.events) {
          for (const event of result.events) {
            await this.eventBus.publish(event);
          }
        }
      }

      return result;
    } catch (error) {
      const executionTime = Date.now() - startTime;

      logger.error(`Command failed: ${command.type}`, {
        commandId: command.id,
        error: error instanceof Error ? error.message : 'Unknown error',
        executionTime,
      });

      // Publish command failed event
      if (this.eventBus) {
        await this.eventBus.publish({
          type: 'command.failed',
          data: {
            commandId: command.id,
            commandType: command.type,
            error: error instanceof Error ? error.message : 'Unknown error',
            executionTime,
          },
        });
      }

      return {
        success: false,
        error: error instanceof Error ? error : new Error('Unknown error'),
        metadata: { executionTime },
      };
    }
  }

  /**
   * Execute command through middleware chain.
   */
  private async executeWithMiddleware(
    command: Command,
    middlewareIndex: number,
  ): Promise<CommandResult> {
    if (middlewareIndex >= this.middleware.length) {
      // End of middleware chain, execute the actual handler
      return this.executeHandler(command);
    }

    const middleware = this.middleware[middlewareIndex];
    if (!middleware) {
      throw new Error(`Middleware at index ${middlewareIndex} is undefined`);
    }
    return middleware(command, () => this.executeWithMiddleware(command, middlewareIndex + 1));
  }

  /**
   * Execute the command handler.
   */
  private async executeHandler(command: Command): Promise<CommandResult> {
    const handler = this.handlers.get(command.type);
    if (!handler) {
      throw new Error(`No handler registered for command: ${command.type}`);
    }

    // Validate command if handler supports it
    if (handler.validate) {
      await handler.validate(command);
    }

    return handler.handle(command);
  }

  /**
   * Get list of registered command types.
   */
  getRegisteredCommands(): string[] {
    return Array.from(this.handlers.keys());
  }

  /**
   * Get handler metadata for a command type.
   */
  getHandlerMetadata(commandType: string): any {
    const handler = this.handlers.get(commandType);
    return handler?.getMetadata?.() || null;
  }
}

/**
 * Query bus for managing query execution in CQRS architecture.
 *
 * The query bus:
 * - Routes queries to appropriate handlers
 * - Provides caching capabilities
 * - Supports read-only projections
 * - Provides performance monitoring
 *
 * @example
 * ```typescript
 * const queryBus = new QueryBus();
 *
 * // Register a handler
 * queryBus.register('user.get', new GetUserHandler());
 *
 * // Execute a query
 * const result = await queryBus.execute({
 *   type: 'user.get',
 *   filters: { id: 'user-123' }
 * });
 * ```
 */
export class QueryBus {
  private handlers = new Map<string, QueryHandler>();
  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();
  private middleware: Array<
    (query: Query, next: () => Promise<QueryResult>) => Promise<QueryResult>
  > = [];

  constructor(private eventBus?: EventBus) {}

  /**
   * Register a query handler for a specific query type.
   */
  register(queryType: string, handler: QueryHandler): void {
    if (this.handlers.has(queryType)) {
      throw new Error(`Handler already registered for query type: ${queryType}`);
    }

    this.handlers.set(queryType, handler);

    logger.debug(`Query handler registered: ${queryType}`, {
      handlerName: handler.getMetadata?.().name || 'Unknown',
    });
  }

  /**
   * Unregister a query handler.
   */
  unregister(queryType: string): boolean {
    const removed = this.handlers.delete(queryType);
    if (removed) {
      logger.debug(`Query handler unregistered: ${queryType}`);
    }
    return removed;
  }

  /**
   * Add middleware to the query processing pipeline.
   */
  use(middleware: (query: Query, next: () => Promise<QueryResult>) => Promise<QueryResult>): void {
    this.middleware.push(middleware);
  }

  /**
   * Execute a query through the registered handler.
   */
  async execute<TQuery, TResult>(query: Query<TQuery>): Promise<QueryResult<TResult>> {
    const startTime = Date.now();
    const queryId = uuidv4();

    logger.debug(`Executing query: ${query.type}`, {
      queryId,
      type: query.type,
      requestedBy: query.requestedBy,
    });

    try {
      // Check cache first
      const cacheKey = this.getCacheKey(query);
      const cached = this.getFromCache(cacheKey);
      if (cached) {
        logger.debug(`Query result served from cache: ${query.type}`, { queryId });
        return cached;
      }

      // Publish query started event
      if (this.eventBus) {
        await this.eventBus.publish({
          type: 'query.started',
          data: {
            queryId,
            queryType: query.type,
            requestedBy: query.requestedBy,
          },
        });
      }

      // Execute through middleware chain
      const result = await this.executeWithMiddleware(query, 0);

      const executionTime = Date.now() - startTime;

      // Cache the result if appropriate
      this.cacheResult(cacheKey, result, query);

      logger.debug(`Query executed successfully: ${query.type}`, {
        queryId,
        executionTime,
        resultSize: Array.isArray(result.data) ? result.data.length : 1,
      });

      // Publish query completed event
      if (this.eventBus) {
        await this.eventBus.publish({
          type: 'query.completed',
          data: {
            queryId,
            queryType: query.type,
            executionTime,
            fromCache: false,
            resultSize: Array.isArray(result.data) ? result.data.length : 1,
          },
        });
      }

      return result;
    } catch (error) {
      const executionTime = Date.now() - startTime;

      logger.error(`Query failed: ${query.type}`, {
        queryId,
        error: error instanceof Error ? error.message : 'Unknown error',
        executionTime,
      });

      // Publish query failed event
      if (this.eventBus) {
        await this.eventBus.publish({
          type: 'query.failed',
          data: {
            queryId,
            queryType: query.type,
            error: error instanceof Error ? error.message : 'Unknown error',
            executionTime,
          },
        });
      }

      throw error;
    }
  }

  /**
   * Execute query through middleware chain.
   */
  private async executeWithMiddleware(query: Query, middlewareIndex: number): Promise<QueryResult> {
    if (middlewareIndex >= this.middleware.length) {
      // End of middleware chain, execute the actual handler
      return this.executeHandler(query);
    }

    const middleware = this.middleware[middlewareIndex];
    if (!middleware) {
      throw new Error(`Query middleware at index ${middlewareIndex} is undefined`);
    }
    return middleware(query, () => this.executeWithMiddleware(query, middlewareIndex + 1));
  }

  /**
   * Execute the query handler.
   */
  private async executeHandler(query: Query): Promise<QueryResult> {
    const handler = this.handlers.get(query.type);
    if (!handler) {
      throw new Error(`No handler registered for query: ${query.type}`);
    }

    // Validate query if handler supports it
    if (handler.validate) {
      await handler.validate(query);
    }

    return handler.handle(query);
  }

  /**
   * Generate cache key for a query.
   */
  private getCacheKey(query: Query): string {
    const keyData = {
      type: query.type,
      filters: query.filters,
      projection: query.projection,
      sort: query.sort,
      limit: query.limit,
      offset: query.offset,
      options: query.options,
    };

    return `query:${Buffer.from(JSON.stringify(keyData)).toString('base64')}`;
  }

  /**
   * Get result from cache if available and not expired.
   */
  private getFromCache(cacheKey: string): QueryResult | null {
    const cached = this.cache.get(cacheKey);
    if (!cached) return null;

    if (Date.now() - cached.timestamp > cached.ttl) {
      this.cache.delete(cacheKey);
      return null;
    }

    return cached.data;
  }

  /**
   * Cache query result with TTL.
   */
  private cacheResult(cacheKey: string, result: QueryResult, query: Query): void {
    // Default TTL: 5 minutes for simple queries, 1 minute for complex queries
    const defaultTtl = query.filters && Object.keys(query.filters).length > 3 ? 60000 : 300000;
    const ttl = (query.options as any)?.cacheTtl || defaultTtl;

    if (ttl > 0) {
      this.cache.set(cacheKey, {
        data: result,
        timestamp: Date.now(),
        ttl,
      });

      // Cleanup old cache entries periodically
      this.cleanupCache();
    }
  }

  /**
   * Clean up expired cache entries.
   */
  private cleanupCache(): void {
    const now = Date.now();
    for (const [key, cached] of this.cache.entries()) {
      if (now - cached.timestamp > cached.ttl) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * Clear cache entries matching a pattern.
   */
  clearCache(pattern?: string): void {
    if (!pattern) {
      this.cache.clear();
      return;
    }

    const regex = new RegExp(pattern);
    for (const key of this.cache.keys()) {
      if (regex.test(key)) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * Get list of registered query types.
   */
  getRegisteredQueries(): string[] {
    return Array.from(this.handlers.keys());
  }

  /**
   * Get handler metadata for a query type.
   */
  getHandlerMetadata(queryType: string): any {
    const handler = this.handlers.get(queryType);
    return handler?.getMetadata?.() || null;
  }

  /**
   * Get cache statistics.
   */
  getCacheStats(): {
    size: number;
    entries: Array<{ key: string; age: number; ttl: number }>;
  } {
    const now = Date.now();
    const entries = Array.from(this.cache.entries()).map(([key, cached]) => ({
      key,
      age: now - cached.timestamp,
      ttl: cached.ttl,
    }));

    return {
      size: this.cache.size,
      entries,
    };
  }
}

/**
 * CQRS middleware for common cross-cutting concerns.
 */
export namespace CQRSMiddleware {
  /**
   * Logging middleware for commands.
   */
  export function logging() {
    return async (command: Command, next: () => Promise<CommandResult>): Promise<CommandResult> => {
      const startTime = Date.now();

      logger.info(`[COMMAND] ${command.type} started`, {
        commandId: command.id,
        issuedBy: command.issuedBy,
      });

      try {
        const result = await next();
        const duration = Date.now() - startTime;

        logger.info(`[COMMAND] ${command.type} completed`, {
          commandId: command.id,
          success: result.success,
          duration,
        });

        return result;
      } catch (error) {
        const duration = Date.now() - startTime;

        logger.error(`[COMMAND] ${command.type} failed`, {
          commandId: command.id,
          error: error instanceof Error ? error.message : 'Unknown error',
          duration,
        });

        throw error;
      }
    };
  }

  /**
   * Validation middleware for commands.
   */
  export function validation(schema: any) {
    return async (command: Command, next: () => Promise<CommandResult>): Promise<CommandResult> => {
      // Validate command data against schema
      const validation = schema.safeParse(command.data);
      if (!validation.success) {
        throw new Error(`Command validation failed: ${validation.error.message}`);
      }

      return next();
    };
  }

  /**
   * Authorization middleware for commands.
   */
  export function authorization(authorizer: (command: Command) => Promise<boolean>) {
    return async (command: Command, next: () => Promise<CommandResult>): Promise<CommandResult> => {
      const authorized = await authorizer(command);
      if (!authorized) {
        throw new Error(`Unauthorized to execute command: ${command.type}`);
      }

      return next();
    };
  }

  /**
   * Rate limiting middleware for commands.
   */
  export function rateLimit(requestsPerMinute: number) {
    const requests = new Map<string, number[]>();

    return async (command: Command, next: () => Promise<CommandResult>): Promise<CommandResult> => {
      const key = command.issuedBy || 'anonymous';
      const now = Date.now();
      const minute = Math.floor(now / 60000);

      const userRequests = requests.get(key) || [];
      const recentRequests = userRequests.filter(time => time === minute);

      if (recentRequests.length >= requestsPerMinute) {
        throw new Error(`Rate limit exceeded: ${requestsPerMinute} requests per minute`);
      }

      recentRequests.push(minute);
      requests.set(key, recentRequests);

      return next();
    };
  }
}

/**
 * Factory for creating CQRS buses with common configurations.
 */
export class CQRSFactory {
  /**
   * Create a command bus with standard middleware.
   */
  static createCommandBus(eventBus?: EventBus): CommandBus {
    const commandBus = new CommandBus(eventBus);

    // Add standard middleware
    commandBus.use(CQRSMiddleware.logging());

    return commandBus;
  }

  /**
   * Create a query bus with standard middleware.
   */
  static createQueryBus(eventBus?: EventBus): QueryBus {
    const queryBus = new QueryBus(eventBus);

    return queryBus;
  }

  /**
   * Create both command and query buses as a pair.
   */
  static createCQRSBuses(eventBus?: EventBus): {
    commandBus: CommandBus;
    queryBus: QueryBus;
  } {
    return {
      commandBus: this.createCommandBus(eventBus),
      queryBus: this.createQueryBus(eventBus),
    };
  }
}
